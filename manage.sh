#!/bin/bash

# --- Configuration ---
INSTALL_DIR="/mnt/bot"
PYTHON_EXECUTABLE="/usr/bin/python3"

# --- Colors ---
C_RESET='\033[0m'
C_RED='\033[0;31m'
C_GREEN='\033[0;32m'
C_YELLOW='\033[0;33m'
C_BLUE='\033[0;34m'
C_CYAN='\033[0;36m'
C_LIGHT_GRAY='\033[0;37m'

# --- Helper Functions ---
check_root() {
    if [ "$(id -u)" -ne 0 ]; then
        echo -e "${C_RED}❌ This script must be run as root. Please use sudo.${C_RESET}"
        exit 1
    fi
}

press_enter_to_continue() {
    echo ""
    # Using echo -n -e and read separately for better compatibility
    echo -n -e "${C_YELLOW}Press Enter to return to the menu...${C_RESET}"
    read
}

# --- Bot Management Functions ---
list_bots() {
    echo -e "${C_CYAN}Available bots:${C_RESET}"
    if [ ! -d "$INSTALL_DIR" ] || [ -z "$(ls -A $INSTALL_DIR/*.py 2>/dev/null)" ]; then
        echo -e "${C_YELLOW}No bots installed yet.${C_RESET}"
        return 1
    fi
    
    mapfile -t bots < <(ls -1 "$INSTALL_DIR"/*.py | xargs -n 1 basename | sed 's/\.py$//')
    
    for i in "${!bots[@]}"; do
        echo -e "  ${C_GREEN}$((i+1)))${C_RESET} ${bots[$i]}"
    done
    
    echo ""
    read -p "Select a bot by number (or press Enter to cancel): " choice
    
    # Validate choice
    if [[ ! "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt "${#bots[@]}" ]; then
        SELECTED_BOT=""
        echo -e "${C_RED}Invalid selection or cancelled.${C_RESET}"
        return 1
    fi
    
    SELECTED_BOT="${bots[$((choice-1))]}"
    return 0
}

# --- Core Functionalities ---
install_new_bot() {
    echo -e "${C_BLUE}--- Installing a New Backup Bot ---${C_RESET}"
    
    # Dependency Check and Install
    echo "Ensuring dependencies (python3, pip, curl, requests, pysocks) are installed..."
    if command -v apt-get &> /dev/null; then
        apt-get update -y && apt-get install -y python3 python3-pip curl
    elif command -v yum &> /dev/null; then
        yum install -y python3 python3-pip curl
    fi
    if command -v pip3 &> /dev/null; then
        pip3 install -U requests pysocks
    fi

    # Get User Input
    read -p "Enter a unique name for this bot/service (e.g., MyServer1, no spaces): " BOT_NAME
    BOT_NAME=$(echo "$BOT_NAME" | tr -d '[:space:]' | tr -cd '[:alnum:]_-')

    if [ -f "$INSTALL_DIR/${BOT_NAME}.py" ]; then
        echo -e "${C_RED}Error: A bot with this name already exists.${C_RESET}"
        return
    fi

    # Multiple Bot Tokens
    read -p "How many Telegram bot tokens? [default 1]: " NUM_BOTS
    NUM_BOTS=${NUM_BOTS:-1}
    BOT_TOKENS=()
    for (( i=1; i<=NUM_BOTS; i++ )); do
        read -p "Enter Telegram Bot Token #$i: " TMP_TOKEN
        BOT_TOKENS+=("$TMP_TOKEN")
    done

    # Multiple Chat IDs
    read -p "How many Telegram chat IDs? [default 1]: " NUM_CHATS
    NUM_CHATS=${NUM_CHATS:-1}
    CHAT_IDS=()
    for (( i=1; i<=NUM_CHATS; i++ )); do
        read -p "Enter Telegram Chat ID #$i: " TMP_CHAT
        CHAT_IDS+=("$TMP_CHAT")
    done
    read -p "Enter 3x-ui Panel URL (e.g., http://127.0.0.1:2053): " PANEL_URL
    read -p "Enter 3x-ui Panel Username: " PANEL_USERNAME
    read -p "Enter 3x-ui Panel Password: " PANEL_PASSWORD
    echo "Proxy configuration (leave blank to skip):"
    read -p "  Proxy host (e.g., 127.0.0.1): " PROXY_HOST
    read -p "  Proxy port (e.g., 3663): " PROXY_PORT
    read -p "  Proxy username (optional): " PROXY_USER
    read -p "  Proxy password (optional): " PROXY_PASS
    PROXY_STRING=""
    if [[ -n "$PROXY_HOST" && -n "$PROXY_PORT" ]]; then
        if [[ -n "$PROXY_USER" || -n "$PROXY_PASS" ]]; then
            PROXY_STRING="socks5h://${PROXY_USER}:${PROXY_PASS}@${PROXY_HOST}:${PROXY_PORT}"
        else
            PROXY_STRING="socks5h://${PROXY_HOST}:${PROXY_PORT}"
        fi
    fi

    # Prepare Python Script
    mkdir -p "$INSTALL_DIR"
    PYTHON_SCRIPT_PATH="$INSTALL_DIR/${BOT_NAME}.py"
    BACKUP_FILENAME="${BOT_NAME}-backup.db"

    # Generate Python script using a heredoc
    cat > "$PYTHON_SCRIPT_PATH" << EOL
# --- Settings Section (Auto-generated by script) ---
BOT_TOKENS = [$(printf '"%s", ' "${BOT_TOKENS[@]}" | sed 's/, $//')]
CHAT_IDS = [$(printf '"%s", ' "${CHAT_IDS[@]}" | sed 's/, $//')]
PANEL_URL = "${PANEL_URL}"
PANEL_USERNAME = "${PANEL_USERNAME}"
PANEL_PASSWORD = "${PANEL_PASSWORD}"
CUSTOM_NAME = "${BOT_NAME}"
BACKUP_FILENAME = "${BACKUP_FILENAME}"
BACKUP_INTERVAL = 3600
PROXY_URL = "${PROXY_STRING}"

# --- Do not edit below this line ---
import requests, time, datetime, json

def get_proxies():
    if PROXY_URL:
        return {'http': PROXY_URL, 'https': PROXY_URL}
    return None

def get_session():
    session = requests.Session()
    session.verify = False
    requests.packages.urllib3.disable_warnings()

    login_url = f"{PANEL_URL}/login"
    payload = {"username": PANEL_USERNAME, "password": PANEL_PASSWORD}
    
    try:
        response = session.post(login_url, json=payload, timeout=10, proxies=get_proxies())
        if response.status_code == 200 and ('session' in session.cookies or '3x-ui' in session.cookies):
            print("✅ Login successful and session cookie received.")
            return session
        else:
            print(f"❌ Login failed. Status: {response.status_code}, Response: {response.text}")
            return None
    except requests.exceptions.RequestException as e:
        print(f"❌ Panel connection error during login: {e}")
        return None

def get_public_ip():
    candidates = [
        ("https://api.ipify.org?format=json", True),
        ("https://ifconfig.me/ip", False),
        ("https://ipinfo.io/json", True),
    ]
    # Try without proxy first, then with proxy if available
    for url, is_json in candidates:
        try:
            resp = requests.get(url, timeout=6)
            if resp.status_code == 200:
                if is_json:
                    data = resp.json()
                    return data.get("ip") or data.get("ip_address") or str(data)
                else:
                    return resp.text.strip()
        except Exception:
            pass
    for url, is_json in candidates:
        try:
            resp = requests.get(url, timeout=8, proxies=get_proxies())
            if resp.status_code == 200:
                if is_json:
                    data = resp.json()
                    return data.get("ip") or data.get("ip_address") or str(data)
                else:
                    return resp.text.strip()
        except Exception:
            pass
    return "unknown"

def get_backup_content(session):
    if not session:
        return None
    
    backup_url = f"{PANEL_URL}/server/getDb"
    try:
        print("Downloading backup file...")
        response = session.get(backup_url, timeout=20, proxies=get_proxies())
        if response.status_code == 200 and response.content:
            # A simple check to see if it's likely a database file not an html page
            if response.content.startswith(b'SQLite format 3'):
                print("✅ Backup file downloaded successfully.")
                return response.content
            else:
                print("❌ Downloaded file is not a valid SQLite DB. Probably a login page due to failed auth.")
                return None
        else:
            print(f"❌ Failed to download backup file. Status: {response.status_code}")
            return None
    except requests.exceptions.RequestException as e:
        print(f"❌ Network error while downloading backup: {e}")
        return None

def send_to_telegram(db_content):
    if not db_content: return
    print("Sending backup to Telegram...")
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    public_ip = get_public_ip()
    caption = (f"📅 **API Backup | {timestamp}**\\n\\n"
               f"🖥️ Server: {CUSTOM_NAME}\\n"
               f"🌐 IP: {public_ip}")

    files = {'document': (BACKUP_FILENAME, db_content)}

    for token in BOT_TOKENS:
        url = f"https://api.telegram.org/bot{token}/sendDocument"
        for chat_id in CHAT_IDS:
            data = {'chat_id': chat_id, 'caption': caption, 'parse_mode': 'Markdown'}
            try:
                response = requests.post(url, data=data, files=files, timeout=20, proxies=get_proxies())
                if response.status_code == 200:
                    print(f"✅ Backup sent (via proxy) to bot {token[:7]}.. and chat {chat_id}.")
                    continue
                else:
                    print(f"⚠️ Telegram proxy send failed: {response.text}")
            except Exception as e:
                print(f"⚠️ Telegram proxy connection error: {e}")

            # Fallback: retry without proxy
            try:
                print("Retrying Telegram send without proxy...")
                response = requests.post(url, data=data, files=files, timeout=20)
                if response.status_code == 200:
                    print(f"✅ Backup sent (no proxy) to bot {token[:7]}.. and chat {chat_id}.")
                else:
                    print(f"❌ Telegram sending error (no proxy): {response.text}")
            except Exception as e:
                print(f"❌ Telegram connection error (no proxy): {e}")

def main_loop():
    while True:
        print(f"\\n--- Running backup for {CUSTOM_NAME} ---")
        session = get_session()
        backup_data = get_backup_content(session)
        if backup_data: 
            send_to_telegram(backup_data)
        print(f"--- Process finished. Next run in {BACKUP_INTERVAL / 3600:.1f} hour(s). ---")
        time.sleep(BACKUP_INTERVAL)

if __name__ == "__main__":
    print(f">>> Initial test for {CUSTOM_NAME}...")
    s = get_session()
    backup = get_backup_content(s)
    if backup:
        send_to_telegram(backup)
    main_loop()
EOL

    # Create and start systemd service
    SERVICE_FILE_PATH="/etc/systemd/system/${BOT_NAME}.service"
    cat > "$SERVICE_FILE_PATH" << EOL
[Unit]
Description=3x-ui Telegram Backup Bot (${BOT_NAME})
After=network.target
[Service]
Type=simple
User=root
ExecStart=${PYTHON_EXECUTABLE} ${PYTHON_SCRIPT_PATH}
Restart=always
RestartSec=10
[Install]
WantedBy=multi-user.target
EOL

    systemctl daemon-reload
    systemctl enable "${BOT_NAME}.service"
    systemctl start "${BOT_NAME}.service"
    
    echo -e "${C_GREEN}✅ Bot '${BOT_NAME}' installed and started successfully!${C_RESET}"
}

uninstall_bot() {
    echo -e "${C_BLUE}--- Uninstall a Backup Bot ---${C_RESET}"
    if ! list_bots; then return; fi
    
    read -p "Are you sure you want to PERMANENTLY delete '${SELECTED_BOT}'? (y/n): " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "Uninstall cancelled."
        return
    fi
    
    echo "Stopping and disabling service..."
    systemctl stop "${SELECTED_BOT}.service" &>/dev/null || true
    systemctl disable "${SELECTED_BOT}.service" &>/dev/null || true
    
    echo "Deleting files..."
    rm -f "/etc/systemd/system/${SELECTED_BOT}.service"
    rm -f "$INSTALL_DIR/${SELECTED_BOT}.py"
    
    systemctl daemon-reload
    
    echo -e "${C_GREEN}✅ Bot '${SELECTED_BOT}' has been successfully uninstalled.${C_RESET}"
}

edit_bot() {
    echo -e "${C_BLUE}--- Edit a Bot's Configuration ---${C_RESET}"
    if ! list_bots; then return; fi

    SCRIPT_PATH="$INSTALL_DIR/${SELECTED_BOT}.py"

    # Helpers to get/set values
    get_str_val() {
        grep -oP "^$1 = \"\K[^\"]+" "$SCRIPT_PATH" || echo ""
    }
    get_list_vals() {
        local var="$1"
        local raw
        raw=$(grep -oP "^${var} = \[.*\]" "$SCRIPT_PATH" | sed -E "s/^${var} = \[(.*)\]/\1/")
        echo "$raw" | grep -oP '"[^\"]+"' | sed 's/\"//g'
    }
    write_list_vals() {
        local var="$1"; shift
        local arr=("$@")
        local joined
        if [ ${#arr[@]} -eq 0 ]; then
            joined=""
        else
            joined=$(printf '"%s", ' "${arr[@]}" | sed 's/, $//')
        fi
        sed -i "s|^${var} = \[.*\]|${var} = [${joined}]|" "$SCRIPT_PATH"
    }

    show_current() {
        echo -e "${C_CYAN}Current configuration:${C_RESET}"
        echo -n "BOT_TOKENS: "; printf '%s ' $(get_list_vals BOT_TOKENS); echo ""
        echo -n "CHAT_IDS: "; printf '%s ' $(get_list_vals CHAT_IDS); echo ""
        echo "PANEL_URL: $(get_str_val PANEL_URL)"
        echo "PANEL_USERNAME: $(get_str_val PANEL_USERNAME)"
        echo "PROXY_URL: $(get_str_val PROXY_URL)"
    }

    manage_list_menu() {
        local var_name="$1"
        while true; do
            echo -e "\nManage ${var_name}:"
            mapfile -t items < <(get_list_vals "$var_name")
            if [ ${#items[@]} -eq 0 ]; then
                echo "  (empty)"
            else
                for i in "${!items[@]}"; do
                    echo "  $((i+1))) ${items[$i]}"
                done
            fi
            echo "  a) Add"
            echo "  r) Remove by number"
            echo "  c) Clear all"
            echo "  b) Back"
            read -p "Select: " choice
            case "$choice" in
                a|A)
                    read -p "Enter value to add: " newv
                    if [ -n "$newv" ]; then
                        items+=("$newv")
                        write_list_vals "$var_name" "${items[@]}"
                        echo "Added."
                    fi
                    ;;
                r|R)
                    read -p "Enter number to remove: " idx
                    if [[ "$idx" =~ ^[0-9]+$ ]] && [ "$idx" -ge 1 ] && [ "$idx" -le ${#items[@]} ]; then
                        unset 'items[$((idx-1))]'
                        # Rebuild array to close gaps
                        local tmp=()
                        for v in "${items[@]}"; do tmp+=("$v"); done
                        items=("${tmp[@]}")
                        write_list_vals "$var_name" "${items[@]}"
                        echo "Removed."
                    else
                        echo "Invalid index."
                    fi
                    ;;
                c|C)
                    items=()
                    write_list_vals "$var_name" "${items[@]}"
                    echo "Cleared."
                    ;;
                b|B)
                    break
                    ;;
                *) echo "Invalid choice.";;
            esac
        done
    }

    edit_proxy_menu() {
        local current
        current=$(get_str_val PROXY_URL)
        echo -e "Current PROXY_URL: ${C_LIGHT_GRAY}${current}${C_RESET}"
        read -p "Proxy host (blank to keep): " ph
        read -p "Proxy port (blank to keep): " pp
        read -p "Proxy username (blank to keep): " pu
        read -p "Proxy password (blank to keep): " pw
        local newurl=""
        if [ -n "$ph" ] && [ -n "$pp" ]; then
            if [ -n "$pu" ] || [ -n "$pw" ]; then
                newurl="socks5h://${pu}:${pw}@${ph}:${pp}"
            else
                newurl="socks5h://${ph}:${pp}"
            fi
        fi
        if [ -n "$newurl" ]; then
            sed -i "s|^PROXY_URL = \".*\"|PROXY_URL = \"${newurl}\"|" "$SCRIPT_PATH"
            echo "Proxy updated."
        else
            echo "Proxy unchanged."
        fi
    }

    while true; do
        echo -e "\n${C_CYAN}Edit Menu for ${SELECTED_BOT}:${C_RESET}"
        echo "1) Show current configuration"
        echo "2) Manage bot tokens (add/remove)"
        echo "3) Manage chat IDs (add/remove)"
        echo "4) Edit proxy (host/port/user/pass)"
        echo "5) Edit panel URL"
        echo "6) Edit panel username"
        echo "7) Edit panel password"
        echo "8) Restart bot"
        echo "9) Back"
        read -p "Select an option: " opt
        case "$opt" in
            1) show_current ;;
            2) manage_list_menu BOT_TOKENS ;;
            3) manage_list_menu CHAT_IDS ;;
            4) edit_proxy_menu ;;
            5)
                cur=$(get_str_val PANEL_URL)
                echo -n -e "New Panel URL [Current: ${C_LIGHT_GRAY}${cur}${C_RESET}]: "
                read nv
                [ -n "$nv" ] && sed -i "s|^PANEL_URL = \".*\"|PANEL_URL = \"${nv}\"|" "$SCRIPT_PATH"
                ;;
            6)
                cur=$(get_str_val PANEL_USERNAME)
                echo -n -e "New Panel Username [Current: ${C_LIGHT_GRAY}${cur}${C_RESET}]: "
                read nv
                [ -n "$nv" ] && sed -i "s|^PANEL_USERNAME = \".*\"|PANEL_USERNAME = \"${nv}\"|" "$SCRIPT_PATH"
                ;;
            7)
                echo -n -e "New Panel Password [Current: ${C_LIGHT_GRAY}hidden${C_RESET}]: "
                read nv
                [ -n "$nv" ] && sed -i "s|^PANEL_PASSWORD = \".*\"|PANEL_PASSWORD = \"${nv}\"|" "$SCRIPT_PATH"
                ;;
            8)
                echo -e "\n${C_YELLOW}Restarting bot to apply changes...${C_RESET}"
                systemctl restart "${SELECTED_BOT}"
                echo -e "${C_GREEN}✅ Bot '${SELECTED_BOT}' restarted.${C_RESET}"
                ;;
            9) break ;;
            *) echo -e "${C_RED}Invalid option.${C_RESET}" ;;
        esac
    done
}


manage_bots() {
    echo -e "${C_BLUE}--- Manage an Existing Bot ---${C_RESET}"
    if ! list_bots; then return; fi
    
    while true; do
        echo -e "\n${C_CYAN}Managing bot: ${SELECTED_BOT}${C_RESET}"
        echo "1) Start"
        echo "2) Stop"
        echo "3) Restart"
        echo "4) Status"
        echo "5) View Logs"
        echo "6) Back to Main Menu"
        read -p "Select an option: " manage_choice
        
        case $manage_choice in
            1) systemctl start "${SELECTED_BOT}"; echo -e "${C_GREEN}Service started.${C_RESET}";;
            2) systemctl stop "${SELECTED_BOT}"; echo -e "${C_YELLOW}Service stopped.${C_RESET}";;
            3) systemctl restart "${SELECTED_BOT}"; echo -e "${C_GREEN}Service restarted.${C_RESET}";;
            4) systemctl status "${SELECTED_BOT}";;
            5) journalctl -u "${SELECTED_BOT}" -f --no-pager;;
            6) break;;
            *) echo -e "${C_RED}Invalid option.${C_RESET}";;
        esac
    done
}


# --- Main Menu ---
main_menu() {
    check_root
    while true; do
        clear
        echo -e "${C_CYAN}=====================================================${C_RESET}"
        echo -e "${C_BLUE}     3x-ui Telegram Backup Bot Management Panel      ${C_RESET}"
        echo -e "${C_CYAN}=====================================================${C_RESET}"
        echo "1) Install a new bot"
        echo "2) Uninstall a bot"
        echo "3) Edit a bot's configuration"
        echo "4) Manage a bot (start/stop/logs)"
        echo "5) Exit"
        echo ""
        read -p "Select an option [1-5]: " main_choice
        
        case $main_choice in
            1) install_new_bot; press_enter_to_continue;;
            2) uninstall_bot; press_enter_to_continue;;
            3) edit_bot; press_enter_to_continue;;
            4) manage_bots;;
            5) exit 0;;
            *) echo -e "${C_RED}Invalid option, please try again.${C_RESET}"; sleep 1;;
        esac
    done
}

main_menu
